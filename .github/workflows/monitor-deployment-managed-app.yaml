# Copyright © 2024, SAS Institute Inc., Cary, NC, USA.  All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

---
name: (RW) Monitor Deployment Managed Application
run-name: monitor-deployment-managed-app

on:
  workflow_call:
    inputs:
      #Required inputs
      environment:
        description: 'The environment to deploy the managed application to.'
        required: true
        type: string
      mapp_mrg_name:
        description: 'The name for the managed application resource group.'
        required: true
        type: string
      monitor_script_name:
        description: 'The name for the script to monitor in the managed applicaton resource group.'
        required: false
        type: string
      pollInterval:
        description: 'The interval in seconds to poll the managed application status.'
        required: true
        type: string
      maxDurationInSeconds:
        description: 'The maximum duration in seconds to wait for the managed application to be created.'
        required: true
        type: string
      lastMonitoringJobFlag:
        description: 'Flag to indicate if this is the last monitoring job for the managed application.'
        required: false
        type: boolean
        default: false
      artifact_name:
        description: 'The name of the artifact to upload.'
        required: true
        type: string

    outputs:
      status:
        description: 'The status of the managed application deployment.'
        value: ${{ jobs.monitor-deployment-managed-app.outputs.status }}
      LB_IP:
        description: 'The load balancer IP address of the managed application.'
        value: ${{ jobs.monitor-deployment-managed-app.outputs.LB_IP }}
      K8S_API_FQDN:
        description: 'The Kubernetes API FQDN of the managed application.'
        value: ${{ jobs.monitor-deployment-managed-app.outputs.K8S_API_FQDN }}

permissions:
  id-token: write
  contents: read

jobs:
  monitor-deployment-managed-app:
    name: monitor-deployment-managed-app
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    outputs:
      status: ${{ steps.monitor-deployment.outputs.status }}
      LB_IP: ${{ steps.monitor-deployment.outputs.LB_IP }}
      K8S_API_FQDN: ${{ steps.monitor-deployment.outputs.K8S_API_FQDN }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Monitor Deployment
        id: monitor-deployment
        shell: bash
        env:
          managed_rg: ${{ inputs.mapp_mrg_name }}
          monitor_script_name: ${{ inputs.monitor_script_name }}
          pollInterval: ${{ inputs.pollInterval }}
          maxDurationInSeconds: ${{ inputs.maxDurationInSeconds }}
          subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          deployment_script_name="${managed_rg/-mrg/-ds-viya-deploy}"
          if [ -z "${monitor_script_name}" ]
          then
            echo "No monitor_script_name supplied. This will use the default of ${deployment_script_name}"
          else
            deployment_script_name="${monitor_script_name}"
            echo "Monitoring the supplied input script name of ${deployment_script_name}"
          fi

          DEPLOYMENT_SCRIPT_JSON=$(az deployment-scripts show -g ${managed_rg} --name ${deployment_script_name} --subscription ${subscription_id})
          DEPLOYMENT_SCRIPT_NAME=$(echo "$DEPLOYMENT_SCRIPT_JSON" | jq -r ".name")

          echo 
          echo "********************************************"
          echo "Monitoring status of deployment script $DEPLOYMENT_SCRIPT_NAME"
          echo "********************************************"

          rm -rf oldlog.txt
          touch oldlog.txt
          
          start_datetime=$(date +%s)
          while true
          do
              if [ "$(date +%s)" -gt "$(($start_datetime + ${maxDurationInSeconds}))" ]
              then
                  if [  "${{ inputs.lastMonitoringJobFlag }}" == 'true' ]
                  then
                      echo "ERROR - It took too much time to complete the managed app execution. Aborting..." 
                      echo "⏰ Timeout reached"
                      echo "status=TIMEOUT" >> "$GITHUB_OUTPUT"
                      exit 1
                  else
                      echo "WARNING - It takes too much time to complete the managed app execution. Resuming monitoring in the next job..." 
                      echo "⏰ Timeout reached"
                      echo "status=TIMEOUT" >> "$GITHUB_OUTPUT"
                      exit 0
                  fi
              fi
              
              #We need to get the updated version of the JSON
              DEPLOYMENT_SCRIPT_JSON=$(az deployment-scripts show -g ${managed_rg} --name ${deployment_script_name} --subscription ${subscription_id})
              DEPLOYMENT_SCRIPT_PROVISIONINGSTATE=$(echo "$DEPLOYMENT_SCRIPT_JSON" | jq -r ".provisioningState")
              DEPLOYMENT_SCRIPT_NAME=$(echo "$DEPLOYMENT_SCRIPT_JSON" | jq -r ".name")
              DEPLOYMENT_SCRIPT_STATUS_ERROR=$(echo "$DEPLOYMENT_SCRIPT_JSON" | jq -r ".status.error")
              DEPLOYMENT_SCRIPT_STATUS_ENDTIME=$(echo "$DEPLOYMENT_SCRIPT_JSON" | jq -r ".status.endTime")
              
              if [ "$DEPLOYMENT_SCRIPT_PROVISIONINGSTATE" == "Failed" ]
              then
                  echo "ERROR - An error occured with the deployment $DEPLOYMENT_SCRIPT_NAME. Aborting..."
                  echo "❌ Deployment failed"
                  echo "status=FAILED" >> "$GITHUB_OUTPUT"
                  exit 1
              else
                  if [ "$DEPLOYMENT_SCRIPT_STATUS_ENDTIME" == "null" ]
                  then
                      echo "The script $DEPLOYMENT_SCRIPT_NAME is still running."
                      DEPLOYMENT_SCRIPT_STATUS_STORAGE_ACCOUNT_ID=$(echo "$DEPLOYMENT_SCRIPT_JSON" | jq -r ".status.storageAccountId")
                      STORAGE_ACCOUNT_NAME=$(echo $DEPLOYMENT_SCRIPT_STATUS_STORAGE_ACCOUNT_ID | perl -p -e "s/\/subscriptions\/${subscription_id}\/resourceGroups\/${managed_rg}\/providers\/Microsoft.Storage\/storageAccounts\/(.*)/\1/")
                      STORAGE_ACCOUNT_KEY=$(az storage account keys list --resource-group $managed_rg --account-name $STORAGE_ACCOUNT_NAME --subscription ${subscription_id} --query "[0].value" -o tsv)
                      STORAGE_SHARE_NAME=$(az storage share list --account-name "${STORAGE_ACCOUNT_NAME}" --account-key "${STORAGE_ACCOUNT_KEY}" --subscription ${subscription_id} | jq -r ".[0].name")
                      STORAGE_SHARE_PATH="azscriptoutput"
                      STORAGE_SHARE_FILE=$(az storage file list --account-name "${STORAGE_ACCOUNT_NAME}" --share-name ${STORAGE_SHARE_NAME} --account-key "${STORAGE_ACCOUNT_KEY}" --subscription ${subscription_id} --path ${STORAGE_SHARE_PATH} | jq -r ".[0].name")
                      if [ -z "STORAGE_SHARE_FILE" ] || [ "$STORAGE_SHARE_FILE" == "null" ]
                      then
                          echo "WARNING - The file $STORAGE_SHARE_FILE does not exist yet in the share $STORAGE_SHARE_NAME." 
                      else
                          az storage file download --path  ${STORAGE_SHARE_PATH}/${STORAGE_SHARE_FILE}  --account-name ${STORAGE_ACCOUNT_NAME} --share-name ${STORAGE_SHARE_NAME} --account-key ${STORAGE_ACCOUNT_KEY} --subscription ${subscription_id} --dest ./${STORAGE_SHARE_FILE} >/dev/null
                          cat ./${STORAGE_SHARE_FILE} > newlog.txt
                          diff --unified=0 oldlog.txt newlog.txt \
                            | grep '^+[^+]' \
                            | sed 's/^+//' \
                            | grep -v '^Alive\[' \
                            | grep -v '^Finished\[' \
                            > diff.txt || true
                          cat diff.txt
                          mv newlog.txt oldlog.txt
                      fi
                      echo "sleeping $pollInterval seconds"
                      sleep $pollInterval  
                  elif [ "$(date +%s)" -gt "$(date -d $DEPLOYMENT_SCRIPT_STATUS_ENDTIME +%s)" ]
                  then 
                      echo "The script execution has completed."
                      break
                  else
                      echo "sleeping $pollInterval seconds"
                      sleep $pollInterval
                  fi
              fi
          done
        

          echo "Retrieve the load balancer IP address."
          MC_RG=$(az aks show --resource-group ${managed_rg} --name ${managed_rg/-mrg/-aks} --query nodeResourceGroup --output tsv --subscription $subscription_id)
          LB_IP=$(az network public-ip list --resource-group $MC_RG --query "[?contains(name, 'kubernetes')].ipAddress" --output tsv --subscription $subscription_id)
          if [ -z "$LB_IP" ] || [ "$LB_IP" == "null" ]
          then
              echo "ERROR - The load balancer IP address could not be retrieved. Aborting..."
              echo "❌ Deployment failed"
              echo "status=FAILED" >> "$GITHUB_OUTPUT"
              exit 1
          fi
          echo "Load balancer IP address: $LB_IP"
          echo "LB_IP=$LB_IP" >> $GITHUB_OUTPUT

          echo "Retrieve the K8S API FQDN."
          K8S_API_FQDN=$(az aks show --resource-group ${managed_rg} --name ${managed_rg/-mrg/-aks} --query "fqdn" --output tsv --subscription $subscription_id)

          if [ -z "$K8S_API_FQDN" ] || [ "$K8S_API_FQDN" == "null" ]
          then
              echo "ERROR - The K8S API FQDN address could not be retrieved. Aborting..."
              echo "❌ Deployment failed"
              echo "status=FAILED" >> "$GITHUB_OUTPUT"
              exit 1
          fi 
          echo "K8S API FQDN: $K8S_API_FQDN"
          echo "K8S_API_FQDN=$K8S_API_FQDN" >> $GITHUB_OUTPUT


          echo "The managed application has been successfully deployed."
          echo "✅ Deployment succeeded"
          echo "status=SUCCEEDED" >> "$GITHUB_OUTPUT"
          

      - name: Prepare artifact
        run: |
          touch ${{ inputs.artifact_name }}
          echo "status=${{ steps.monitor-deployment.outputs.status }}" >> ${{ inputs.artifact_name }}
          echo "LB_IP=${{ steps.monitor-deployment.outputs.LB_IP }}" >> ${{ inputs.artifact_name }}
          echo "K8S_API_FQDN=${{ steps.monitor-deployment.outputs.K8S_API_FQDN }}" >> ${{ inputs.artifact_name }}
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ inputs.artifact_name }}
